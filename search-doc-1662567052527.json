[{"title":"PlayFab","type":0,"sectionRef":"#","url":"docs/Integration/PlayFab","content":"PlayFab Coming Soon™.","keywords":""},{"title":"VS Code","type":0,"sectionRef":"#","url":"docs/Integration/VSCode","content":"VS Code To begin working with Midas you need to install the relevant wally package at `nightcycle/midas', adding the versioning of the most recent release at the end. As a wally package it can be retrieved from throughout the game's code. All of the code composing the package is luau strict typechecking compliant, and if you index it directly using luau-lsp it will be detected by the VS Code intellisense, saving you time memorizing a new API. The package also exports multiple custom luau types that may be useful in your own code, you may access them using wally-package-types created by the same talented individual. This is my own workflow, however it is not necessary to use Midas, just recommended. Once you are done installing and integrating the package into your VS Code workspace, the next step is integrating it into your Roblox code.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/intro","content":"Overview The goal of this documentation is to give you everything you need to know to succeed. Setting up analytics can be complicated business, but if you follow these guides you should be up and running in now time. The integration section is especially important for first-time set-up. The other pages are mostly highlighting various bits of functionality that may be useful to you in your own workflow but aren't necessary for a vanilla use-case.","keywords":""},{"title":"Series Events","type":0,"sectionRef":"#","url":"docs/SeriesEvents","content":"Series Events Coming Soon™.","keywords":""},{"title":"Teleporting Players","type":0,"sectionRef":"#","url":"docs/Teleportation","content":"Teleporting Players Coming Soon™.","keywords":""},{"title":"Power Bi","type":0,"sectionRef":"#","url":"docs/Integration/PowerBi","content":"Power Bi Coming Soon™.","keywords":""},{"title":"Using Templates","type":0,"sectionRef":"#","url":"docs/Templates","content":"Using Templates Coming Soon™.","keywords":""},{"title":"Midas","type":0,"sectionRef":"#","url":"api/Midas","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Midas","url":"api/Midas#functions","content":" "},{"title":"Destroy​","type":1,"pageTitle":"Midas","url":"api/Midas#Destroy","content":"&lt;/&gt; Midas:Destroy() → () Destroys the midas object  "},{"title":"SetTag​","type":1,"pageTitle":"Midas","url":"api/Midas#SetTag","content":"&lt;/&gt; Midas:SetTag(key: string) → nil Adds a tag to all future events from the midas object.  "},{"title":"RemoveTag​","type":1,"pageTitle":"Midas","url":"api/Midas#RemoveTag","content":"&lt;/&gt; Midas:RemoveTag(key: string) → nil Removes tag from all future events from the midas object.  "},{"title":"SetCondition​","type":1,"pageTitle":"Midas","url":"api/Midas#SetCondition","content":"&lt;/&gt; Midas:SetCondition( key: string, func: () → boolean ) → nil Allows for the binding of fire condition blockers. If any return false the midas will not fire.  "},{"title":"SetRoundingPrecision​","type":1,"pageTitle":"Midas","url":"api/Midas#SetRoundingPrecision","content":"&lt;/&gt; Midas:SetRoundingPrecision(exp: number?) → nil Returns the hierarchy path the midas object was created under. Sets the rounding precision of all numbers and vectors to 10^exp paramter. If not exponent parameter is provided it defaults to 0.  "},{"title":"Compile​","type":1,"pageTitle":"Midas","url":"api/Midas#Compile","content":"&lt;/&gt; Midas:Compile() → {[string]: any}?--serveronly Creates a dictionary of values resulting from invoking the bound state functions / objects.  "},{"title":"GetUTC​","type":1,"pageTitle":"Midas","url":"api/Midas#GetUTC","content":"&lt;/&gt; Midas:GetUTC(offset: number?) → string Returns a UTC format compliant timestamp string from the current tick. An optional offset can be applied to this in seconds.  "},{"title":"CanFire​","type":1,"pageTitle":"Midas","url":"api/Midas#CanFire","content":"&lt;/&gt; Midas:CanFire() → boolean Determines if a midas object meets all the bound conditions.  "},{"title":"Fire​","type":1,"pageTitle":"Midas","url":"api/Midas#Fire","content":"&lt;/&gt; Midas:Fire( eventName: string, seriesDuration: number?, includeEndEvent: boolean? ) → nil Fires an event. If series duration is included it will delay sending the event until that duration has passed. It can also fire an end event in that case.  "},{"title":"SetChance​","type":1,"pageTitle":"Midas","url":"api/Midas#SetChance","content":"&lt;/&gt; Midas:SetChance(val: number) → nil Forces the midas object to roll the dice before firing future events. Default is 1, which will always fire the event.  "},{"title":"GetBoundStateCount​","type":1,"pageTitle":"Midas","url":"api/Midas#GetBoundStateCount","content":"&lt;/&gt; Midas:GetBoundStateCount() → number Gets the number of states currently bound to the midas object. "},{"title":"Interface","type":0,"sectionRef":"#","url":"api/Interface","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Interface","url":"api/Interface#functions","content":" "},{"title":"init​","type":1,"pageTitle":"Interface","url":"api/Interface#init","content":"This item only works when running on the server. Server &lt;/&gt; Interface.init( titleId: string, devSecretKey: string ) → nil Call this on the server to connect PlayFab prior to firing any events.  "},{"title":"Configure​","type":1,"pageTitle":"Interface","url":"api/Interface#Configure","content":"This item only works when running on the server. Server &lt;/&gt; Interface:Configure(deltaConfig: ConfigurationData) → nil "},{"title":"Types","type":1,"pageTitle":"Interface","url":"api/Interface##","content":""},{"title":"​","type":1,"pageTitle":"Interface","url":"api/Interface#ConfigurationData","content":"type ConfigurationData = { Version: string, SendDeltaState: boolean, SendDataToPlayFab: boolean, Templates: { Join: boolean, Chat: boolean, Population: boolean, ServerPerformance: boolean, Market: boolean, Exit: boolean, Character: boolean, Demographics: boolean, Policy: boolean, ClientPerformance: boolean, Settings: boolean, }, }  Allows for the replacement of the default config table, changing the behavior of the framework.  "},{"title":"InsertTeleportDataEntry​","type":1,"pageTitle":"Interface","url":"api/Interface#InsertTeleportDataEntry","content":"This item only works when running on the server. Server &lt;/&gt; Interface:InsertTeleportDataEntry( player: Player , teleportData: {[any]: any}? ) → { MidasAnalyticsData: TeleportDataEntry, [any]: any } When a player is being teleported, pass the teleport data prior to teleporting them through this API. This will ensure the session is tracked as continuing.  "},{"title":"GetEventSignal​","type":1,"pageTitle":"Interface","url":"api/Interface#GetEventSignal","content":"This item only works when running on the server. Server &lt;/&gt; Interface:GetEventSignal() → _Signal.Signal Provides a pseudo-RBXScriptSignal which will fire whenever an event is sent via HttpService. When the Signal is fired it will provide the playerId, path, data, tags, and timestamp in that order. "},{"title":"Roblox","type":0,"sectionRef":"#","url":"docs/Integration/Roblox","content":"","keywords":""},{"title":"Initial Set-Up​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#initial-set-up","content":"These are the things you need to complete for each game. "},{"title":"Configuring the Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#configuring-the-framework","content":"In order to best support your workflow you can configure many different aspects of the framework. You can read up further on the properties available to configure under the ConfigurationData type on the Interface API page, however you don't need to write to all of them when configuring. In the below example only about half of the variables are being set. Typically you should at least set the version as you'll want to be able to tell which version of the game data originates from. You must run this script on the server for it to work, otherwise it will error.  local WallyPackages = game.ReplicatedStorage.Packages local MidasAnalytics = require(WallyPackages.Midas) MidasAnalytics:Configure({ Version = &quot;0.1.0&quot;, SendDeltaState = false, Templates = { Join = true, Chat = false, Demographics = true, Policy = false, Settings = false, } })  "},{"title":"Initializing the Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#initializing-the-framework","content":"Assuming you are using the native PlayFab based data storage solution, you will want to initialize the framework with the TitleId and Dev Secret Key. As you may have guessed from the name &quot;Dev Secret Key&quot;, it's a secret. Since it's a secret please run this in a script stored exclusively under ServerScriptService to avoid exploiters from finding it.  local TITLE_ID = &quot;ABC123&quot; local DEV_SECRET_KEY = &quot;A1B2C3D4E5F6G7H8I9&quot; MidasAnalytics.init(TITLE_ID, DEV_SECRET_KEY)  "},{"title":"Connecting Players to Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#connecting-players-to-framework","content":"The framework automatically detects new players entering and will bind them to the relevant data templates as dictated in the configuration. Since some templates record client-side information it's important that you require the Midas framework package on both client and server, otherwise you can experience some data loss. "},{"title":"Using Midaii​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#using-midaii","content":"At the heart of the Midas framework is a &quot;Midas&quot;, plurally known as &quot;Midaii&quot;. These are little data collection helpers that do a ton of work behind the scenes to make data collection and event firing as easy as possible. "},{"title":"Constructing a Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#constructing-a-midas","content":"Midaii can be constructed on the server or client. In the below example we'll be creating a Midas for a player's sword. local player = game.Players.LocalPlayer local path = &quot;Combat/Weapon/Sword&quot; local swordMidas = MidasAnalytics:GetMidas(player, path)  The path variable provides context on where to store the information in the eventual dataset, a functionality we explore further farther down on this page. You also don't need to worry about garbage collection, as Midaii delete themselves when a player leaves. If a Midas with the same path already exists it will pass you that Midas rather than creating a new one. "},{"title":"Binding State to Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#binding-state-to-midas","content":"If there's data you'd like to track, just attach it to a Midas!  local swordKills = 0 swordMidas:SetState(&quot;Kills&quot;, function() return swordKills end) local damagePerSecond = 0 swordMidas:SetState(&quot;DPS&quot;, function() return damagePerSecond end)  In order to keep things simple, rather than binding the information directly to the Midas you instead provide a function it can call to get the current value. This allows for the easy tracking of local variables without needing to manually update the Midas whenever one of them changes. "},{"title":"Firing an Event from Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#firing-an-event-from-midas","content":"It was game designer Sid Meier who once said &quot;A game is a series of interesting choices.&quot;, as a game analyst it's your job to track those choices to see if they're interesting. Here's an example of an event you might fire if the sword just got equipped.  swordMidas:Fire(&quot;Equipped&quot;)  The event itself will fire to framework (even if it's on the client), where it will be formatted and bundled and sent off to PlayFab / your custom data storage solution. The key itself doesn't need to be unique, as it is actually added onto the end of the path variable set when the midas was constructed. For example, &quot;Equipped&quot; is recorded as &quot;Combat/Weapon/Sword/Equipped&quot;. You may notice that there is no place to include extra information with the fired events unlike many other libraries. I've gone back and forth on whether to add support for one-off data binding with events, but for now I feel it is best for you to bind all useful data, no matter how temporary, as a state. Should you not want to use PlayFab to store your data, on the server use MidasAnalytics:GetEventSignal() to have all the compiled event data sent directly to you, allowing you to hook it up and send wherever is needed. This function can also be quite useful for debugging. "},{"title":"The Midas Hierarchy​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#the-midas-hierarchy","content":"Whenever a Midas is fired, the framework basically takes a photograph of the entire game. Every single Midas registerred to a player is compiled, calling their bound state functions and returning tables with their outputs. Then, using the path variable of each midas, the resulting data is organized into a singular massive data structure.  { Combat: { Weapon: { Sword: { Kills: 0, DPS: 0, } } } }  In the above example, you can see how it separated the path into layers of tables with a single Midas. A more complicated table with multiple Midaii will look something like this:  { FriendsInServer: { Old: 2, New: 1, }, Combat: { Weapon: { Sword: { Kills: 0, DPS: 0, Blade: { IsPoison: false, Sharpness: 0.5, Length: 3, }, } Gun: { Kills: 0 Range: 50 }, }, Stats: { Deaths: 6, Kills: 3, KDR: 0.5, } Health: 0 }, Map: { Lighting: { Precipitation: 0, Fog: 0.5, Brightness: 0.5, ClockTime: 15.63, }, Biome: &quot;Forest&quot;, NearbyPlayers: 2, } }  This mega-table is constructed every single time a Midas is fired. This table is then sent with the event to PlayFab / your data storage solution. If after encoding your table is larger than 500 characters it will error and the event will be lost. There are a few things you can do to avoid this. Cutting Back on Templates​ In the initial configuration you can create various template Midaii to track useful data about the player. While all of the data tracked is useful, not all of it is equally useful. For example if your game is relatively small and has no reason to worry about lag, consider cutting the ServerPerformance and ClientPerformance templates. The ServerPerformance template is particularly massive due to it's recording of a ton of peripheral data. Some other templates you may consider filtering for a reduced size are the Demographics and Settings templates. The Demographics template contains a ton of useful information ranging from account age to platform to language, however if you're fairly confident in who your audience is it may make more sense to create your own custom alternative with less information. Only Recording Changes in State​ If the SendDeltaState configuration variable is flipped to true, when compiling the mega-table above it will only include data which has changed since the previous event. This can cut down on the amount of data dramatically, however it brings in two new issues: increased difficulty in unloading data, and increased risk of data loss. Of the two, the increased difficulty unloading data can be trivial if you know what you're doing. Basically, when you query the data in Power Bi later, you need to sort the events by session id, then sort them by index / order. From there you can use a function called &quot;Fill Down&quot; which will take the previous value and insert it below when the cell is empty. It slows down the query a bit, but once the query is set-up you likely won't run it more than a few times an hour. The real issue of this method is that there's an elevated chance for data corruption. -- Character health is tracked by a Midas. local health = 100 characterMidas:SetState(&quot;Health&quot;, function() return health end) --Character is damaged health = 2 characterMidas:Fire(&quot;ReceiveDamage&quot;) --ERROR, THIS FAILED! -- Character runs away characterMidas:Fire(&quot;Flee&quot;)  In the above scenario, because the delta state failed, when the tables are later filled down the Flee event will be attributed a health of 100 because that was the last health update it received. As you can guess, having a character flee at full health and at almost 0 health are very different experiences - this is why this method is arguably more dangerous. I've included with each event a baked in roblox-side index so that you can estimate how many events are missing. For example if you receive an event with index 4 and an event with index 6, you know 5 didn't make it through. In my experience, around 1% of events tend to disappear currently. Since with analytics you're dealing with sample sizes in the thousands, usually the error caused by this across such a large group isn't a huge issue as for every player who missed that key moment, there are another 99 who recorded it. Over time I plan to add more safeguards, such as handling failed events more intelligently, as well as sprinkling in a few unchanged states to ensure a higher change of correcting failures early. That being said, this will always be more of a risk than the method which sends an entire copy of the player's state each time. "},{"title":"Conclusion​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#conclusion","content":"And that's about it! There are a few useful functions and utilities worth learning that will improve your quality of life, but the bare necessities are complete. Now that you've completed sending the data, it's time to catch that data on the storage side. "}]