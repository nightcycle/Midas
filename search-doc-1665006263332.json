[{"title":"VS Code","type":0,"sectionRef":"#","url":"docs/Integration/VSCode","content":"VS Code To begin working with Midas you need to install the relevant wally package at `nightcycle/midas', adding the versioning of the most recent release at the end. As a wally package it can be retrieved from throughout the game's code. All of the code composing the package is luau strict typechecking compliant, and if you index it directly using luau-lsp it will be detected by the VS Code intellisense, saving you time memorizing a new API. The package also exports multiple custom luau types that may be useful in your own code, you may access them using wally-package-types created by the same talented individual. This is my own workflow, however it is not necessary to use Midas, just recommended. Once you are done installing and integrating the package into your VS Code workspace, the next step is integrating it into your Roblox code.","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/intro","content":"Overview The goal of this documentation is to give you everything you need to know to succeed. Setting up analytics can be complicated business, but if you follow these guides you should be up and running in now time. The integration section is especially important for first-time set-up. The other pages are mostly highlighting various bits of functionality that may be useful to you in your own workflow but aren't necessary for a vanilla use-case.","keywords":""},{"title":"Series Events","type":0,"sectionRef":"#","url":"docs/SeriesEvents","content":"Series Events Coming Soon™.","keywords":""},{"title":"Teleporting Players","type":0,"sectionRef":"#","url":"docs/Teleportation","content":"Teleporting Players Coming Soon™.","keywords":""},{"title":"PlayFab","type":0,"sectionRef":"#","url":"docs/Integration/PlayFab","content":"","keywords":""},{"title":"Why PlayFab?​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#why-playfab","content":"The online service PlayFab will allow you 100,000 users worth of data-storage for free per game. You're welcome to shop-around for better options, but it is in my experience more than adequate for kickstarting a new game. If you have an established game with larger a larger audience, they offer a pay-as-you-go option, and at $99 a month the amount of players that can be stored becomes unlimited. "},{"title":"I don't want to use PlayFab​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#i-dont-want-to-use-playfab","content":"Alright, all you technicall need is a CSV of data that meets this format: &quot;DATA&quot;,&quot;TIMESTAMP&quot;,&quot;VERSION&quot;,&quot;VERSION_TEXT&quot;,&quot;EVENT_ID&quot;, &quot;EVENT&quot;,  The header order doesn't matter. Here's what needs to be under each column DATA: This should be an encoded JSON table provided in the body of the API post request at &quot;State&quot;TIMESTAMP: A string that can be parsed into a DateTime object. For example: &quot;2022-09-28T21:53:49.859Z&quot;VERSION: An encoded JSON table provided within the DATA JSON table.VERSION_TEXT: A readable version string provided at key &quot;Version&quot; in the API post request.EVENT_ID: A 32 character string that is unique for each event.EVENT: The name of the event fired. So long as whatever your method in results in a CSV file that fits the above conditions, you do not need to use PlayFab to use this Framework. If there is enough demand for a separate workflow that does this for you (for example, with GameAnalytics), I am not against adding it, I'm just unmotivated at this time. "},{"title":"Retrieving the Data via PlayFab​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#retrieving-the-data-via-playfab","content":"This is how you can get your data out of PlayFab after it's been recorded.If you haven't already, first create an account and a &quot;Title&quot; entity for your game. After completing that, go into your new Title's profile and on the menu on the left side at the very bottom click the &quot;Data&quot; button under the &quot;Analyze&quot; category. Once you've done that you will now be looking at the &quot;Data Explorer (basic)&quot;. At the top of the page is a tab for &quot;Data Explorer (advanced)&quot;. Click that tab, and you'll be taken to one of the most cluttered and temperamental code editing UX I have ever used. This is the KQL editor, and you can use it to run KQL code which will output data at the bottom. First, copy the text in the export.kql file. The way this code works, is it starts by finding players who were recorded in your game between the TIME_RANGE_START and TIME_RANGE_END variables. It then searches the entire database for all events relating to those users. This is so that the user profiles are accurate - if a person played your game 100 times in the last year, but only 1 time in the time range, you'll want to know that. As a bonus, this also easily allows you to compare how a current version of the game is performing against a previous version. You may also set a PLAYER_COUNT limit, this will arbitrarily limit the amount of users recorded. Once you've pasted and configured the KQL code into the PlayFab editor, press &quot;Run&quot; in the upper left hand corner of the editor. If it runs correctly you should see a table appear at the bottom. If you do, select the dropdown menu labeled &quot;File&quot; in the upper right side of the editor, and press the option &quot;Export to CSV&quot;. This will download the data to your computer. "},{"title":"Troubleshooting PlayFab​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#troubleshooting-playfab","content":"The less you have the troubleshoot PlayFab the happier you will be. Most of the errors tell you &quot;An Error Occurrred&quot; and nothing else. Here are some potential reasons an error could have occurred. "},{"title":"Your Authentication Expired​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#your-authentication-expired","content":"So, for whatever reason sometimes if I keep a PlayFab tab open for a few hours, when I run a query - even a very simple one, it errors. I'm still logged in, but I guess some internal authentication key needs to be updated. To fix this, just refresh the page and try again. Don't trust the editor to save your code though - I almost always write it in VSCode then copy it over because of this. "},{"title":"The Code Isn't Selected​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#the-code-isnt-selected","content":"You didn't select the code you wanted to run. In KQL the entire query needs to be a single block of text (though you can connect things with comments if this is too annoying). It will be slightly highlighted if it's selected. Also, the selection detection is not bulletproof, feel free to click the code again and retry. KQL is one of the few languages where just running the code again can fix the problem. "},{"title":"Query Is Too Big​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#query-is-too-big","content":"Many users, especially those with established games, will not be able to export all their data at once. Depending on the amount you store + the number of events per session, you can usually get around 500-2000 sessions of data in a single go. This is why the KQL script I provided has a start / end time variable. If your data is too big, I recommend downloading it in chunks. You can import as many CSVs as you want into the upcoming Power Bi step - all you need to do is put them under the same folder, you don't even need to name them anything. The python script ahead will deduplicate the data as needed. "},{"title":"Can I Automate This?​","type":1,"pageTitle":"PlayFab","url":"docs/Integration/PlayFab#can-i-automate-this","content":"Yes you can. It will require you to create an AAD account in your microsoft workspace, and then using its credentials to perform API calls to retrieve the data. From there you can manually write it into a CSV or bypass the CSV step entirely and modify the upcoming Python script to work with the data you've retrieved. This is a process that took me hours to get right, and whenever I had to set up a new project it would take another hour because I'd forget. Automation is possible, but I'm not sure it's worth it for most devs. Doing it manually takes around 3-5 boring minutes. You don't have to worry about rate limits. And you only have to do this once per update. The goal of Midas is not to provide a live feed of how your game is doing, it's meant to allow you to do an in-depth study into how an update has influenced the player experiences in your game. I have gone through this process over a dozen times, and frankly all trying to automate it seems to accomplish for me is headaches. "},{"title":"Midas","type":0,"sectionRef":"#","url":"api/Midas","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Midas","url":"api/Midas#functions","content":" "},{"title":"Destroy​","type":1,"pageTitle":"Midas","url":"api/Midas#Destroy","content":"&lt;/&gt; Midas:Destroy() → () Destroys the midas object  "},{"title":"SetTag​","type":1,"pageTitle":"Midas","url":"api/Midas#SetTag","content":"&lt;/&gt; Midas:SetTag(key: string) → nil Adds a tag to all future events from the midas object.  "},{"title":"RemoveTag​","type":1,"pageTitle":"Midas","url":"api/Midas#RemoveTag","content":"&lt;/&gt; Midas:RemoveTag(key: string) → nil Removes tag from all future events from the midas object.  "},{"title":"SetCondition​","type":1,"pageTitle":"Midas","url":"api/Midas#SetCondition","content":"&lt;/&gt; Midas:SetCondition( key: string, func: () → boolean ) → nil Allows for the binding of fire condition blockers. If any return false the midas will not fire.  "},{"title":"SetRoundingPrecision​","type":1,"pageTitle":"Midas","url":"api/Midas#SetRoundingPrecision","content":"&lt;/&gt; Midas:SetRoundingPrecision(exp: number?) → nil Sets the rounding precision of all numbers and vectors to 10^exp paramter. If not exponent parameter is provided it defaults to 0.  "},{"title":"_Compile​","type":1,"pageTitle":"Midas","url":"api/Midas#_Compile","content":"&lt;/&gt; Midas:_Compile() → {[string]: any}?--serveronly Creates a dictionary of values resulting from invoking the bound state functions / objects.  "},{"title":"_GetUTC​","type":1,"pageTitle":"Midas","url":"api/Midas#_GetUTC","content":"&lt;/&gt; Midas:_GetUTC(offset: number?) → string Returns a UTC format compliant timestamp string from the current tick. An optional offset can be applied to this in seconds.  "},{"title":"CanFire​","type":1,"pageTitle":"Midas","url":"api/Midas#CanFire","content":"&lt;/&gt; Midas:CanFire() → boolean Determines if a midas object meets all the bound conditions.  "},{"title":"Fire​","type":1,"pageTitle":"Midas","url":"api/Midas#Fire","content":"&lt;/&gt; Midas:Fire( eventName: string, seriesDuration: number?, includeEndEvent: boolean? ) → nil Fires an event. If series duration is included it will delay sending the event until that duration has passed. It can also fire an end event in that case.  "},{"title":"SetChance​","type":1,"pageTitle":"Midas","url":"api/Midas#SetChance","content":"&lt;/&gt; Midas:SetChance(val: number) → nil Forces the midas object to roll the dice before firing future events. Default is 1, which will always fire the event.  "},{"title":"GetBoundStateCount​","type":1,"pageTitle":"Midas","url":"api/Midas#GetBoundStateCount","content":"&lt;/&gt; Midas:GetBoundStateCount() → number Gets the number of states currently bound to the midas object. "},{"title":"Using Templates","type":0,"sectionRef":"#","url":"docs/Templates","content":"Using Templates Coming Soon™.","keywords":""},{"title":"Power BI","type":0,"sectionRef":"#","url":"docs/Integration/PowerBi","content":"","keywords":""},{"title":"Querying in Power BI​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#querying-in-power-bi","content":"One thing though that I don't enjoy very much about Power BI, is the querying language. It's called M Script, and it's quite similar to KQL and SQL, except you have to write it in their garbage code editor. Like KQL and SQL it's also a very different type of programming language to what many game devs are familiar with. It took me almost a week to learn KQL and run basic queries in it within PlayFab - my brain just couldn't wrap itself around the various table datastructures and operations that needed to be used to effectively create and store tables. That being said - I wouldn't have been able to make this framework without that, and if you want to work with massive amounts of data a lot of the quirks in KQL and SQL exist for the purpose of speed. That being said - most people here are game devs, not data scientists, and my goal for the framework is to allow you to improve your game without having to become one. So, to avoid you having to learn M Script I've created a Python script which you can run that will assemble a series of neat tables that you can load directly into Power BI. Formatting the Data with Python Python is a much easier language to work with if you grew up on languages like Lua, Javascript, or any C language. The main reason why you would use SQL over Python, is that SQL is much faster. As the point of this framework is for you to download a lot of data in one go then study it for a while, I felt that using Python was acceptable. "},{"title":"Setting Up the Python Script​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#setting-up-the-python-script","content":"First, if you haven't already, download Python. Once it's installed, you also need to install something called PIP which is essentially the Python version of Lua's Wally or Javascript's NPM. It allows you to download packages that you can use in your code. If you know how to use a terminal, you can run a command in VSCode to automatically download all the required packages. Once you have this done, you will need to run the format.py script. It's under the midas repository, so clone that. Before running the Python script, edit the format.toml file. This file allows you to configure the behavior of the format.py script. "},{"title":"Configuring the Python Script​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#configuring-the-python-script","content":"The &quot;fill_down&quot; category in the toml file has to do with how the python script handles missing data. If you set your in-game analytics package to only send the delta-state (aka, just the changes rather than a copy of the entire state tree), then you are likely to have many gaps in your data. To remedy this, you can enable fill down. If fill down is enabled it will check the prior indexed event in the table for any existing value. If not event exists at the prior index it will return nothing. If it finds one it will copy the data stored. The recursive property allows it to keep checking earlier and earlier events until it finds data. These processes increase the risk of data contamination, especially the recursive one. This allows you to store much less data, and your mileage may vary as to whether or not it's worth the risk. The input and output path variables refer to where it will get and put the data. All the CSVs you downloaded in the previous step should be stored under a folder named &quot;event&quot; at this path location. The CSVs do not need to be named anything specific, and any duplicate events will be ignored. The output folder should have an &quot;event&quot; and a &quot;kpi&quot; folder. After you run the script you will find labelled CSV and parquet files at these locations. If you've never heard of a parquet file, it's basically a CSV file stored in binary, allowing the computer to read and write it much faster. "},{"title":"Running the Python Script​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#running-the-python-script","content":"Once you've set the TOML, you can either run the script in the console or right click it in the VSCode explorer and press &quot;Run Python File in Terminal&quot;. Depending on the size of your data this script can take anywhere between 15 seconds and an hour. Once it's done, it'll write to the output and you're good to import it into Power BI! Working in Power BI I've included a copy of my Dashboard for you to experiment with, but it's not neccessary. Working with data in Power BI (sans querying) is no more difficult than Excel / Google Sheets. "},{"title":"Importing the Data​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#importing-the-data","content":"On the upper left side of the screen under the home ribbon, you can press &quot;Get Data&quot;. From there, a window will pop-up that allows you to select the type of source. Type &quot;Parquet&quot; into source and a button with a blue diamond icon alongside matching text will appear in the list. You can then select that, then press the yellow &quot;Connect&quot; button at the bottom. From there, a URL will pop up. This URL can also be a system path, for example the one I used to import the sessions.parquet file was C:\\Users\\coyer\\Documents\\GitHub\\midas\\dashboard\\output\\kpi\\sessions.parquet, in fact you can even right click the file in VSCode and copy the path directly. I haven't been able to get it to work with relative paths unfortunately, otherwise I'd have done this for you. Go through and import each table. After applying it to Power BI you should see it appear in the panel on the right side of the screen. You are now free to begin messing around with the data! "},{"title":"Relationships and Models​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#relationships-and-models","content":"To begin setting up relationships between data, go to the Models view on the left menu bar of the main Power BI dashboard page. One awesome thing about Power BI is the dynamic filtering. For example, if you set up a relationship between the session id on the sessions table, and the session id on the performance table, you can use a filter to hide all the sessions that lasted less than 30 seconds, and it will also hide all the performance data linked to those sessions in the connected performance table. You can even set relationships to be both ways, meaning that if you filter out all the events from a specific user, that user will also be filtered. This allows for really helpful dynamic KPI measure. For example if you filter the events to just the &quot;Completed Onbaording&quot; equivalent event, it will filter out every user who didn't have that event. This then updated the various measures and visualizations, allowing you to engage with this user group in isolation and even see what your KPIs would be if all players were like this. "},{"title":"Measures​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#measures","content":"Often times you need to summarize data - whether that be get the average revenue across your users, or finding the max ping of a group - you need to be able to define ways to simplify data. There are quick measures you can make by either dragging a variable directly into a visual, however you can also manually create these measures as permanent added-on variables that can do more complicated math in an excel like language called DAX. "},{"title":"Groups / Bins​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#groups--bins","content":"You can create &quot;groups&quot; from variables by right clicking and selecting &quot;New Group&quot; from the menu, allowing you to establish bins of various sizes - really useful for creating histograms. Groups are sometimes referred to as &quot;Bins&quot; in other software. "},{"title":"Visuals​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#visuals","content":"Power BI allows you to visualize data a ton of ways. All you need to do is add one to the dashboard, then drag variables from the fields area to the appropriate visualizations slot. There you can specify how it's summarized, as well as change how it's labelled by right clicking and pressing &quot;Rename for this visual&quot;. "},{"title":"Key Influencers​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#key-influencers","content":"I heavily recommend using the &quot;Key influencers&quot; visual, as you can feed it a ton of variables and tell it to solve for the conditions in which a change in one variable influences another variable. This is amazingly useful for finding hidden patterns in the player behavior from hundreds of different metrics. "},{"title":"Decomposition Tree​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#decomposition-tree","content":"Decomposition trees aren't as useful as Key Influencers, but they're more visually accessible. A decomposition tree allows you to create an N-Dimensional matrix of categories with the goal of finding which ones score the highest in a given metric. I typically use this to see how different platforms and localizations influence KPIs. "},{"title":"Filtering​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#filtering","content":"As I briefly touched on earlier, one of the biggest strengths of Power BI is the ability to dynamically reduce your dataset in meaningful ways, allowing you to engage with specific users and behaviors in isolation. There are various ways to do this. "},{"title":"Clicking a Visual​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#clicking-a-visual","content":"Many visuals in Power BI double as input mechanisms. For example, you can select a bar on a bar chart, and it will filter the data to just the events composing that bar of the chart. Since you can measure KPIs for this changing audience, it can be very useful for composing different player groups that exist within your game. "},{"title":"The Filter Panel​","type":1,"pageTitle":"Power BI","url":"docs/Integration/PowerBi#the-filter-panel","content":"On the right side of the screen next to the visuals and fields panel is a filters panel. Here you can place different variables from the fields area and and decide which values to keep and which to dispose of. There are various domains of filtering, ranging from just the current selected visual, to the entire dashboard. Quite frequently I'll use this to remove outliers, as well as my own data. You can also insert a visual called a &quot;Slicer&quot; which is a slightly more front-end friendly version of the filter panel, allowing you to change variables with things like a slider. Also pro-tip, if when you place a number variable there it lists every single unique value, rather than as a slider, it's because that number is stored as a string. Conclusion Power BI is an awesome tool for sorting through the hyper-complicated systems that are online games. There is a ton of stuff not covered in this document relating to how you can best work with Power Bi - my main focus has just been to give you as clean a dataset as easily as possible, so that you can spend your time focusing on how to actually make sense of the data. Feel free to modify things as you need, none of my work is sacred and I made it with myself in mind first and foremost. My main hope is that this framework provides you a useful starting point for improving your games with complete control over your data. Best of luck! "},{"title":"Interface","type":0,"sectionRef":"#","url":"api/Interface","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Interface","url":"api/Interface#functions","content":" "},{"title":"init​","type":1,"pageTitle":"Interface","url":"api/Interface#init","content":"This item only works when running on the server. Server &lt;/&gt; Interface.init( titleId: string, devSecretKey: string ) → nil Call this on the server to connect PlayFab prior to firing any events.  "},{"title":"Configure​","type":1,"pageTitle":"Interface","url":"api/Interface#Configure","content":"This item only works when running on the server. Server &lt;/&gt; Interface:Configure(deltaConfig: ConfigurationData) → nil "},{"title":"Types","type":1,"pageTitle":"Interface","url":"api/Interface##","content":""},{"title":"​","type":1,"pageTitle":"Interface","url":"api/Interface#ConfigurationData","content":"type ConfigurationData = { Version: { Major: number, Minor: number, Patch: number, Hotfix: number?, Tag: string?, TestGroup: string?, }, SendDeltaState: boolean, PrintLog: boolean, PrintEventsInStudio: boolean, SendDataToPlayFab: boolean, Templates: { Join: boolean, Chat: boolean, Population: boolean, ServerPerformance: boolean, Market: boolean, Exit: boolean, Character: boolean, Demographics: boolean, Policy: boolean, ClientPerformance: boolean, Settings: boolean, ServerIssues: boolean, ClientIssues: boolean, Group: {[string]: number} }, }  Allows for the replacement of the default config table, changing the behavior of the framework.  "},{"title":"InsertTeleportDataEntry​","type":1,"pageTitle":"Interface","url":"api/Interface#InsertTeleportDataEntry","content":"This item only works when running on the server. Server &lt;/&gt; Interface:InsertTeleportDataEntry( player: Player , teleportData: {[any]: any}? ) → { MidasAnalyticsData: TeleportDataEntry, [any]: any, } When a player is being teleported, pass the teleport data prior to teleporting them through this API. This will ensure the session is tracked as continuing.  "},{"title":"GetEventSignal​","type":1,"pageTitle":"Interface","url":"api/Interface#GetEventSignal","content":"This item only works when running on the server. Server &lt;/&gt; Interface:GetEventSignal() → _Signal.Signal Provides a pseudo-RBXScriptSignal which will fire whenever an event is sent via HttpService. When the Signal is fired it will provide the playerId, path, data, tags, and timestamp in that order. "},{"title":"Roblox","type":0,"sectionRef":"#","url":"docs/Integration/Roblox","content":"","keywords":""},{"title":"Initial Set-Up​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#initial-set-up","content":"These are the things you need to complete for each game. "},{"title":"Configuring the Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#configuring-the-framework","content":"In order to best support your workflow you can configure many different aspects of the framework. You can read up further on the properties available to configure under the ConfigurationData type on the Interface API page, however you don't need to write to all of them when configuring. In the below example only about half of the variables are being set. Typically you should at least set the version as you'll want to be able to tell which version of the game data originates from. You must run this script on the server for it to work, otherwise it will error.  local WallyPackages = game.ReplicatedStorage.Packages local MidasAnalytics = require(WallyPackages.Midas) MidasAnalytics:Configure({ Version = { Major = 1, Minor = 0, Patch = 0, Hotfix = 2, Tag = &quot;Alpha&quot;, }, SendDeltaState = false, Templates = { Join = true, Chat = false, Demographics = true, Policy = false, Settings = false, } })  "},{"title":"Initializing the Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#initializing-the-framework","content":"Assuming you are using the native PlayFab based data storage solution, you will want to initialize the framework with the TitleId and Dev Secret Key. As you may have guessed from the name &quot;Dev Secret Key&quot;, it's a secret. Since it's a secret please run this in a script stored exclusively under ServerScriptService to avoid exploiters from finding it.  local TITLE_ID = &quot;ABC123&quot; local DEV_SECRET_KEY = &quot;A1B2C3D4E5F6G7H8I9&quot; MidasAnalytics.init(TITLE_ID, DEV_SECRET_KEY)  "},{"title":"Connecting Players to Framework​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#connecting-players-to-framework","content":"The framework automatically detects new players entering and will bind them to the relevant data templates as dictated in the configuration. Since some templates record client-side information it's important that you require the Midas framework package on both client and server, otherwise you can experience some data loss. "},{"title":"Using Midaii​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#using-midaii","content":"At the heart of the Midas framework is a &quot;Midas&quot;, plurally known as &quot;Midaii&quot;. These are little data collection helpers that do a ton of work behind the scenes to make data collection and event firing as easy as possible. "},{"title":"Constructing a Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#constructing-a-midas","content":"Midaii can be constructed on the server or client. In the below example we'll be creating a Midas for a player's sword. local player = game.Players.LocalPlayer local path = &quot;Combat/Weapon/Sword&quot; local swordMidas = MidasAnalytics:GetMidas(player, path)  The path variable provides context on where to store the information in the eventual dataset, a functionality we explore further farther down on this page. You also don't need to worry about garbage collection, as Midaii delete themselves when a player leaves. If a Midas with the same path already exists it will pass you that Midas rather than creating a new one. "},{"title":"Binding State to Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#binding-state-to-midas","content":"If there's data you'd like to track, just attach it to a Midas!  local swordKills = 0 swordMidas:SetState(&quot;Kills&quot;, function() return swordKills end) local damagePerSecond = 0 swordMidas:SetState(&quot;DPS&quot;, function() return damagePerSecond end)  In order to keep things simple, rather than binding the information directly to the Midas you instead provide a function it can call to get the current value. This allows for the easy tracking of local variables without needing to manually update the Midas whenever one of them changes. "},{"title":"Firing an Event from Midas​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#firing-an-event-from-midas","content":"It was game designer Sid Meier who once said &quot;A game is a series of interesting choices.&quot;, as a game analyst it's your job to track those choices to see if they're interesting. Here's an example of an event you might fire if the sword just got equipped.  swordMidas:Fire(&quot;Equipped&quot;)  The event itself will fire to framework (even if it's on the client), where it will be formatted and bundled and sent off to PlayFab / your custom data storage solution. The key itself doesn't need to be unique, as it is actually added onto the end of the path variable set when the midas was constructed. For example, &quot;Equipped&quot; is recorded as &quot;Combat/Weapon/Sword/Equipped&quot;. You may notice that there is no place to include extra information with the fired events unlike many other libraries. I've gone back and forth on whether to add support for one-off data binding with events, but for now I feel it is best for you to bind all useful data, no matter how temporary, as a state. Should you not want to use PlayFab to store your data, on the server use MidasAnalytics:GetEventSignal() to have all the compiled event data sent directly to you, allowing you to hook it up and send wherever is needed. This function can also be quite useful for debugging. "},{"title":"The Midas Hierarchy​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#the-midas-hierarchy","content":"Whenever a Midas is fired, the framework basically takes a photograph of the entire game. Every single Midas registerred to a player is compiled, calling their bound state functions and returning tables with their outputs. Then, using the path variable of each midas, the resulting data is organized into a singular massive data structure.  { Combat: { Weapon: { Sword: { Kills: 0, DPS: 0, } } } }  In the above example, you can see how it separated the path into layers of tables with a single Midas. A more complicated table with multiple Midaii will look something like this:  { FriendsInServer: { Old: 2, New: 1, }, Combat: { Weapon: { Sword: { Kills: 0, DPS: 0, Blade: { IsPoison: false, Sharpness: 0.5, Length: 3, }, } Gun: { Kills: 0 Range: 50 }, }, Stats: { Deaths: 6, Kills: 3, KDR: 0.5, } Health: 0 }, Map: { Lighting: { Precipitation: 0, Fog: 0.5, Brightness: 0.5, ClockTime: 15.63, }, Biome: &quot;Forest&quot;, NearbyPlayers: 2, } }  This mega-table is constructed every single time a Midas is fired. This table is then sent with the event to PlayFab / your data storage solution. If after encoding your table is larger than 500 characters it will error and the event will be lost. There are a few things you can do to avoid this. Cutting Back on Templates​ In the initial configuration you can create various template Midaii to track useful data about the player. While all of the data tracked is useful, not all of it is equally useful. For example if your game is relatively small and has no reason to worry about lag, consider cutting the ServerPerformance and ClientPerformance templates. The ServerPerformance template is particularly massive due to it's recording of a ton of peripheral data. Some other templates you may consider filtering for a reduced size are the Demographics and Settings templates. The Demographics template contains a ton of useful information ranging from account age to platform to language, however if you're fairly confident in who your audience is it may make more sense to create your own custom alternative with less information. Only Recording Changes in State​ If the SendDeltaState configuration variable is flipped to true, when compiling the mega-table above it will only include data which has changed since the previous event. This can cut down on the amount of data dramatically, however it brings in two new issues: increased difficulty in unloading data, and increased risk of data loss. Of the two, the increased difficulty unloading data can be trivial if you know what you're doing. Basically, when you query the data in Power Bi later, you need to sort the events by session id, then sort them by index / order. From there you can use a function called &quot;Fill Down&quot; which will take the previous value and insert it below when the cell is empty. It slows down the query a bit, but once the query is set-up you likely won't run it more than a few times an hour. The real issue of this method is that there's an elevated chance for data corruption. -- Character health is tracked by a Midas. local health = 100 characterMidas:SetState(&quot;Health&quot;, function() return health end) --Character is damaged health = 2 characterMidas:Fire(&quot;ReceiveDamage&quot;) --ERROR, THIS FAILED! -- Character runs away characterMidas:Fire(&quot;Flee&quot;)  In the above scenario, because the delta state failed, when the tables are later filled down the Flee event will be attributed a health of 100 because that was the last health update it received. As you can guess, having a character flee at full health and at almost 0 health are very different experiences - this is why this method is arguably more dangerous. I've included with each event a baked in roblox-side index so that you can estimate how many events are missing. For example if you receive an event with index 4 and an event with index 6, you know 5 didn't make it through. In my experience, around 1% of events tend to disappear currently. Since with analytics you're dealing with sample sizes in the thousands, usually the error caused by this across such a large group isn't a huge issue as for every player who missed that key moment, there are another 99 who recorded it. Over time I plan to add more safeguards, such as handling failed events more intelligently, as well as sprinkling in a few unchanged states to ensure a higher change of correcting failures early. That being said, this will always be more of a risk than the method which sends an entire copy of the player's state each time. "},{"title":"Conclusion​","type":1,"pageTitle":"Roblox","url":"docs/Integration/Roblox#conclusion","content":"And that's about it! There are a few useful functions and utilities worth learning that will improve your quality of life, but the bare necessities are complete. Now that you've completed sending the data, it's time to catch that data on the storage side. "}]